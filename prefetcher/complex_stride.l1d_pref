#include "cache.h"

// ------------------------- DO NOT CHANGE -------------------------------- //
#define NUM_IP_TABLE_ENTRIES 1024           // IP table entries
#define PREFETCH_DEGREE 5                   // Prefetch degree
// ------------------------- DO NOT CHANGE -------------------------------- //

// ------------ YOU CAN CHANGE THE IP_TABLE FOR YOU DESIGN ---------------- //

#define MIN_STATE_REQ 1
#define NUM_STRIDE_TABLE_ENTRIES 4096

class IP_TABLE {
  public:
    uint64_t ip;
    uint64_t cl_addr;                // last cl offset in the 4KB page 
    uint16_t signature;                     // CPLX signature
    uint64_t last_time; 
 

    IP_TABLE () {
        ip = 0;
        cl_addr = 0;
        signature = 0;
        last_time = 0;
    };

    void reinitialize(uint64_t ip_tag , uint64_t t){
        ip = ip_tag;
        cl_addr = 0;
        signature = 0;
        last_time = t;
    }


};

class STRIDE_TABLE {
    public:
        uint16_t signature;
        uint64_t stride;
        uint64_t state;
        uint64_t last_time;

    
    STRIDE_TABLE(){
        signature = -1;
        stride = 0;
        state = 0;
        last_time = 0;
    }

    void reinitialize(uint16_t signature1,uint64_t t){
        signature = signature1;
        stride = 0;
        state = 0;
        last_time = t;
    }

};

IP_TABLE trackers_table[NUM_IP_TABLE_ENTRIES];
STRIDE_TABLE stride_table[NUM_STRIDE_TABLE_ENTRIES];

uint64_t present_time = 0;




// ------------------------- Updating the signature ---------------------------- // 
uint16_t update_sig_l1(uint16_t old_sig, int delta) {                           
    

    return (old_sig << 3 )^delta;
}

// ------------------- Updating confidence for the CPLX class ------------------ // 
void update_state(STRIDE_TABLE*entry,uint64_t stride) {

    uint64_t conf = entry->state;

    if(entry->stride == stride){
        conf++;
        if(conf > MIN_STATE_REQ + 1)
            conf = MIN_STATE_REQ + 1;
    }
    else{
        if(conf > 0){
            conf--;
        }
    }

    entry->state = conf;

    if(entry->state == 0)
        entry->stride = stride;

}

STRIDE_TABLE* find_entry(uint16_t signature){

    uint64_t min_time = stride_table[0].last_time;
    STRIDE_TABLE*entry =  stride_table;

    for( int i = 0 ; i < NUM_STRIDE_TABLE_ENTRIES ; i++ ){
        if( signature == stride_table[i].signature){

            stride_table[i].last_time = present_time;
            return stride_table + i;
        }

        if( min_time > stride_table[i].last_time){
            entry = stride_table + i;
            min_time = stride_table[i].last_time;
        }

    }

    entry->reinitialize(signature,present_time);
    return entry;
}

IP_TABLE* find_tracker(uint64_t ip){

    uint64_t min_time = trackers_table[0].last_time;
    IP_TABLE*tracker = trackers_table ;

    for( int i = 0 ; i < NUM_IP_TABLE_ENTRIES ; i++ ){
        if( ip == trackers_table[i].ip){
            trackers_table[i].last_time = present_time;
            return trackers_table + i;
        }

        if( min_time > trackers_table[i].last_time){
            tracker = trackers_table + i;
            min_time = trackers_table[i].last_time;
        }

    }

    tracker->reinitialize(ip,present_time);
    return tracker;
}


// ------------------------- Initialize the prefetcher ------------------------- // 
void CACHE::l1d_prefetcher_initialize() 
{

	cout << "CPU " << cpu << " L1D Complex-Stride prefetcher" << endl;
    
}

// --------------- This is the main prefetcher operate function ---------------- // 
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
{
    uint64_t cl_addr = addr >> LOG2_BLOCK_SIZE;

	// --------------------- Add Complex-Stride pf_address logic here --------------------- // 

	// prefetch_line(ip, addr, pf_address, FILL_L1, 0);

    present_time++;

    IP_TABLE*tracker = find_tracker(ip);

    uint64_t stride = cl_addr - tracker->cl_addr;

    uint16_t signature =  update_sig_l1(tracker->signature,stride);

    STRIDE_TABLE*entry = find_entry(signature);


    if( entry->state >= MIN_STATE_REQ ){

        uint64_t stride = entry->stride;

        for( int j = 1 ; j <= PREFETCH_DEGREE ; j++){

            uint64_t pf_addr = ( cl_addr + j*stride )<<LOG2_BLOCK_SIZE;

            // only issue a prefetch if the prefetch address is in the same 4 KB page
            // as the current demand access address

            if ((pf_addr >> LOG2_PAGE_SIZE) == (addr >> LOG2_PAGE_SIZE)){
                prefetch_line(ip,addr ,pf_addr , FILL_L1 , 0);
            }
        }

    }



    STRIDE_TABLE*entry_prev = find_entry(tracker->signature);

    update_state(entry_prev,stride);

    // update tracker for that IP

    tracker->signature = signature;
    tracker->cl_addr = cl_addr;

    return;

}

// ------------------------- DO NOT CHANGE -------------------------------- //
void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_final_stats()
{
	cout << "CPU " << cpu << " L1D complex stride prefetcher final stats" << endl;
	cout << "Degree: " << PREFETCH_DEGREE << endl;
   
}
// ------------------------- DO NOT CHANGE -------------------------------- //